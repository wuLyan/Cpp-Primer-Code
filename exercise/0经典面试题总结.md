# C++面试题汇总

## 基础部分

> :rocket: **C和C++有什么异同？**

- C++(C with classes)引入了类、引用的概念，而C中均没有
- C++引入 new/delete 运算符，取代了C中的 malloc/free 库函数
- C++中允许在程序的任意位置声明变量，而C只允许在程序的开头声明变量
- C++扩展了运算符重载的概念，允许为用户定义的类型重新定义运算符的含义
- C是面向过程编程的语言，而**C++是集面向对象编程、泛型编程和面向过程编程的语言**
- C++中自定义函数时形参列表为空与在括号中使用 void 等效，都表示不接收参数；而在C中括号为空意味着对是否接受参数保持沉默，即可以接收、也可以不接收
- C++对于变量名称的长度无限制，名称中所有的字符都有意义；而ANSI C(C99标准)只保证变量名称中前63个字符有意义，即前63个字符相同的名称被认为是相同的
- C++中认为`int a = 1; int a(1); int a = {1}; int a {1};`四种形式对变量的声明都是合法的，而C只认为`int a = 1;`赋值方式是合法的(其他数组等容器的初始化方式相同)
**综上所述，C++是C的超集，C是C++的子集。**

> :rocket: **getline() 和 get() 有什么异同？**

- 两者都**可以**是 istream 类中的成员函数/类方法，即都是面向行的读取输入函数，都可以通过句点表示法调用，如`cin.getline(*, *);`、`cin.get(*, *);`(但 getline() 也有不是类方法的调用情况，见函数重载)
-  cin.getline(Name, Size) 与 cin.get(Name, Size) 功能相同：第一个参数 Name 是用来存储输入行的数组的名称，第二个参数 Size 是要读取的字符数；两种用法都返回一个 cin 对象，因此有正确用法：`cin.get(Name, Size).get();`与`cin.getline(Name1, Size1).getline(Name2, Size2);` 
- **使用时两者都通过回车键输入的换行符来确定输入结尾**，但 getline() 将丢弃换行符，存储字符串时用空字符来代替换行符；而 get() 并不丢弃，且将其保留在输入队列中，因此需要用如下代码片段来跨过换行符，连续进行多个输入时要特别注意

```C++
while(cin.get() != "\n")
    continue;
```   

- 两者都有函数重载，具体见C++ Primer Plus Chapter 8：因此 get() 存在有不带任何参数的 cin.get() ，该函数可读取单个字符(即便是换行符)，这种用法常在`cin.get(Name, Size);`后面使用，即`cin.get(Name, Size).get();` 
-  getline() 用于读取面向整行的输入，用法`getline(cin, str);` 将 cin 作为参数，指出到哪里去查找输入，另外也没有指出字符串长度的参数，因为 string对象 将根据字符串的长度自动调整自己的大小，即此时的 getline() 是 <string> 的库函数
参考链接：[C++字符&字符串(字符数组)的输入输出](https://blog.csdn.net/Buster001/article/details/100083803)

> :rocket: **string对象 和 字符数组 有什么异同？**

- 使用 string 对象的方式与使用字符数组相同：可以使用C风格字符串(字符串字面值)来初始化 string 对象，可以使用 cin 将键盘输入存储到 string 对象中，可以使用 cout 显示 string 对象，可以使用数组表示法/下标索引来访问存储在 string 对象中的字符
- 可以将 string 对象声明为简单变量，而不是数组；要使用 string 类，必须在程序中包含头文件 <string> ，并且编译命名空间 using namespace std;  
-  string 对象可以互相整体赋值，而字符数组不可以，因为数组名的本质是个常量指针
- 类设计能够让程序自动处理 string 对象的大小，这使得与字符数组相比 string 对象更方便更安全
-  string 类中有类方法 size() ，可以获取 string 对象中包含的字符数，而字符数组只能使用 strlen 函数
- 未被初始化的 string 对象的长度被自动设置为0；而未被初始化的字符数组中第一个空字符的出现位置是随机的，这就给函数 strlen() 的运行结果带来了不确定性
- C++提供了三种表示C-风格字符串的方法：字符数组、字符串字面值和字符串指针，它们的类型都是 char * 

```C++
#include <string>
#include <iostream>

using namespace std;

int main()
{
    string str1;
    string str2 = "panther";

    cout << "Enter a kind of feline: "; //输入fox
    cin >> str1;

    cout << str1 << endl; //输出fox，类似于普通变量的输出方式
    cout << str2[0] << endl; //输出p，采用数组下标索引的方式进行访问

    return 0;
}
```

> :rocket: **sizeof 和 strlen 有什么异同？**

-  sizeof 是一个运算符(类似于加减乘除)，而 strlen 是 cstring 头文件中的库函数
-  sizeof 的参数可以是数据的类型，也可以是变量；而 strlen 只能是以结尾为 ‘\0’ 的字符串(**字符串变量、字符数组**)作参数
- 编译器在编译时就计算出了 sizeof 的结果，而 strlen 函数必须在运行时才能计算出来
-  sizeof 返回的是数据类型占内存的大小；而 strlen 返回的是存储在数组中的字符串的长度，而不是数组本身的长度，另外只包含可见字符，即不包含空字符。因此如果存储 cosmic 字符串，数组的长度不能短于 strlen(cosmic) + 1 
- 数组做 sizeof 的参数不退化，而传递给 strlen 时就退化为指针了

```C++
#include <iostream>
#include <string>

using namespace std;

int main()
{
    int a = 4;
    //操作符sizeof()的参数可以是变量的类型，也可以是变量名
    cout << sizeof(int) << ' ' << sizeof(a) << endl; //输出均为4

    char p[10] = "wuyan";
    cout << sizeof(p) << ' ' << strlen(p) << endl; //前者输出10，后者输出5
    //说明操作符sizeof()返回的是变量所占内存的大小，而函数strlen()返回的是字符串的长度，还不包含空字符
    //在这种情况下，不会将数组名解释为第一个元素的地址，这是数组名与指向数组的指针的区别所在
    return 0;
}
//20230319_sizeof与strlen的区别.cpp
```

> :rocket: **数组名与指向数组的指针有什么异同？**

- 刚开始时它们都指向数组的第一个元素，因此 n[i] 、 pn[i] 、 *(n + i) 与 *(pn + i) 等效，均表示数组的第 i 个元素; &n[i] 、 &pn[i] 、 (n + i) 与 (pn + i) 等效，均表示数组的第 i 个元素的地址( pn 是指向数组 n 的指针)
- 注意 n 与 &n 之间的区别：前者指向数组中的第一个元素，而后者指向整个数组，因此 n + 1 指向数组中的下一个元素，而 &n + 1 指向后面一个12字节内存块(这里认为数组含有三个 int 类型元素，且 int 类型占四个字节)；另一个区别是为了得到数组中的第一个元素，只需对前者解除一次引用，但需要对后者解除两次引用

```C++
#include <iostream>

using namespace std;

int main()
{
    int n[3] = {1, 2, 3};
    int *pn = n;

    cout << n[1] << endl;
    cout << pn[1] << endl;
    cout << *(n + 1) << endl;
    cout << *(pn + 1) << endl;

    cout << &n[1] << endl;
    cout << &pn[1] << endl;
    cout << (n + 1) << endl;
    cout << (pn + 1) << endl;

    cout << n << endl;
    cout << n + 1 << endl;
    cout << &n << endl;
    cout << &n + 1 << endl;
    cout << pn << endl;
    cout << pn + 1 << endl;
    cout << &pn << endl;
    cout << &pn + 1 << endl;

    return 0;
}
//20221117_数组与指针2.cpp
```

- 更多程序见 20220930_数组与指针1.cpp 与 201120_数组与指针2.cpp
- 数组名虽然是数组第一个元素的地址，但它本质上还是个常量，不能修改其值；而指向数组的指针是个变量，因此可以进行指针意义下的加减操作进而更新指向
- 对数组名应用 sizeof 运算符得到的是整个数组的长度(以字节为单位)，而对指向数组的指针应用 sizeof 运算符得到的是指针所占内存空间的长度，即使此时指针指向的是一个数组。即在这种情况下，C++不会将数组名解释为地址
- 对数组名应用地址运算符时，得到的将是整个数组的地址(整个数组长度)，而不是数组中第一个元素的地址
- 对于字符数组要特别注意：在 cout 和多数C++表达式中， char数组名 、 char指针 以及 用引号括起的字符串常量 (存储在静态只读区)都被解释为字符串第一个字符的地址，它们传递给 cout 时，**将打印该地址处的字符，然后继续打印后面的字符，直到遇到空字符为止**。见下面的代码分析：
  
```C++
#include <iostream>

using namespace std;

int main()
{
    char flower[10] = "rose";
    int num[10] = {1, 2, 3};

    cout << flower << endl; //输出rose，因为flower是字符数组
    cout << num << endl; //输出0x62fdf0，因为num是整型数组名，本质上是个指针
    cout << num[0] << endl; //输出1，num[0]是数组中的第一个元素

    return 0;
}
``` 

- 更多内容见C++ Primer Plus 4.8.3小节

> :rocket: **在查看输入方面， cin >> ch 、 cin.get(ch) 、 ch = cin.get()有什么异同 ？**

| 属性| cin.get(ch) | ch = cin.get() |
| :---------: | :---------: |:---------: |
| 传递输入字符的方式 | 赋给参数ch | 将函数返回值赋给ch |
| 用于字符输入时函数的返回值 |  istream 对象(执行 bool 转换后为 true )，因此可以有用法 cin.get(ch1).get(ch2)  |  int 类型的字符编码，与C语言中函数getchar()相似 |
| 到达文件尾时函数的返回值 |  istream 对象(执行 bool 转换后为 false ) | 文件尾EOF |

-  cin >> ch 读取时，读入时使用空白(回车、制表符、换行符)来确定字符串的结束位置，会自动过滤这些空白，遇到后停止读入；**即不会读入这些空白，但并不会将它们从输入队列中删除，在连续进行多个输入时要注意(见C++ Primer Plus P81 程序清单4.6)**；并且之后当用户按下回车键之后，输入的内容才会被发送给程序，进入缓冲；读入完成后， cin 自动在字符串的结尾添加空字符
- 若 cin >> ch 输入内容的类型与存储内容的类型不匹配，将发生：变量 ch 的原内容保持不变、不匹配的输入仍然保留在输入队列中、 cin 对象中的一个错误标记被设置(即读入功能被禁用)、对 cin 方法的调用将返回 false (如果被转换为 bool 类型)(输入错误、输入类型不匹配、文件尾EOF都将导致 cin 返回 false )

```C++
#include  <iostream>

using namespace std;

int main()
{
    int num1, num2;
    cout << "First number" << endl;
    cin >> num1;

    cin.clear(); //当输入类型与存储类型不匹配cin读入功能被禁用时重置输入
    while(cin.get() != '\n'); //消耗类型不匹配的输入，以便进行接下来的输入

    cout << "Last number" << endl;
    cin >> num2;

    cout << "num1 = " << num1 << " , num2 = " << num2 << endl;

    return 0;
}
```

-  cin.get(ch) 在读取字符时，将读取输入中的**下一个字符(即使它是空格)**，并将其赋给变量 ch ，这在一定程度上弥补了用法 cin >> ch 的缺陷
- 到现在，已经接触过 get() 的四种不同用法： cin.get() 、 ch = cin.get() 、 cin.get(ch) 、 cin.get(Name, ArSize) 

> :rocket: **switch 与 if else 有什么异同？**

- 两者都允许程序从选项中进行选择，但相比之下 if else 更加通用
- 例如只有 if else 可以处理**取值范围**问题，而 switch 中的每一个 case 标签都必须对应一个整数(含 char )，因此 switch 无法处理浮点数测试。另外 switch 标签值还必须是常值，无法处理变量的比较或选择问题
- 当然如果所有的选项都可以使用整数常量来表示，且数量多于3个时，就代码长度和执行效率而言， switch 将更加高效

```C++
#include <iostream>
#include <string>
#include <cctype>

using namespace std;

//判断读入的字符是否为元音字母开头
int main()
{
    string words;
    int vowels = 0, consonants = 0, others = 0;

    while (cin >> words)
    {
        if (isalpha(words[0]))
        {
            switch(words[0]) //这里如果要用if结构则需要有十个条件表达式
            {
                case 'a':
                case 'e':
                case 'i':
                case 'o':
                case 'u':
                case 'A':
                case 'E':
                case 'I':
                case 'O':
                case 'U': 
                    vowels++;
                    break;
                default: 
                    consonants++;
            }
        }
        else
        {
            others++
        }
    }

    return 0;
}
``` 

> :rocket: **break 与 continue 有什么异同？**

-  break 既可用在循环中，又可用在 switch 中，而 continue 只可用在循环中
- 当 break 用在循环中时，表示立刻结束循环，转而执行循环体之外的语句；而 continue 用在循环中时，表示跳过循环体剩余部分(即不会跳过 for 循环的更新表达式)，转而执行下一次循环
- 当 break 用在 switch 中时，表示跳过 break 之后的所有 case 

> :rocket: **关键字 const 与指针相结合的三种不同用法有何区别？**

- 用法 const int *pt; 表示 pt 指针可以指向任意 int 类型的变量，但不能通过该指针修改所指向对象的值( const int 限定)，但是这并不代表所指向对象必须是常量，即可以直接通过变量来修改其值，但不能通过 pt 指针修改
- 用法 int *const pt; 表示不能修改 pt 指针以指向其他对象，但是可以通过指针修改当前所指向对象的值
- 用法 const int *const pt; 表示既不能修改 pt 指针以指向其他对象，也不能通过该指针修改所指向对象的值
- 前两种用法的主要区别是关键字 const 与 * 的相对位置关系：若 const 在前表示 *pt 为只读， const 在后表示 pt 为只读
- 如果数据类型不是指针(数组名)(即数据类型与指针之间只有一层间接关系)，则可以将 const 数据或非 const 数据的地址赋给指向 const 的指针，但只能将非 const 数据的地址赋给非 const 指针。因此为了使函数应用范围更广，应将指针形参声明为指向 const 的指针

```C++
const int months[3] = {31, 28, 19};
int sum(int arr[], int n);
int j = sum(months, 3); //报错，编译器不允许将 const 指针赋给非 const 指针
```

- 更多内容见C++ Primer Plus 7.3.5 小节

> :rocket: **左值与右值有何区别？**

- 左值是**可被引用、可以取地址**的数据对象(如变量、数组元素、结构成员、引用和解除引用的指针)，即常规变量和 const 变量都可视为左值，因为可以通过地址访问它们，但常规变量属于可修改的左值，而 const 属于不可修改的左值
- 非左值包括字面常量(用引号括起的字符串除外，它们由其地址表示)和包含多项的表达式
- 赋值语句的左边必须是可修改的左值，即左边的子表达式必须标识一个可修改的内存块，如返回类型为引用的函数。常规函数(返回类型为非引用)的返回值为右值，因为这种返回值位于临时内存单元中，运行到下一条语句时，它们可能不再存在
```C++
#include <iostream>

using namespace std;

int main()
{
    int a = 10;
    int b = 20;
    int c = a + b;

    int *pa = &a;
    int *pb = &b;
    //int *pc = &(a + b); //报错，因为表达式整体是个右值，不能取地址

    int &c = a; //左值引用：左值在赋值符号的右边
    //int &d = 10; //与上一行同为左值引用，赋值符号的右边必须得是左值，这里10是右值，因此会报错
    //int &e = (a + b); //理由同上

    const int &d = 10;
    const int &e = (a + b);
    //使用const限定符定义为常量/临时变量的引用，只能通过引用读取数据，而不能修改数据

    int &&x = 10; //右值引用：右值在赋值符号的右边
    int &&y = (a + b);

    return 0;
}
```   

> :rocket: **为什么在引用参数作形参时应可能使用 const ？**

- 使用 const 可以避免无意中修改数据的编程错误，若在函数中无意修改，则程序会发出警告或报错
- 使用 const 引用使函数能够处理 const 和非 const 实参，否则将只能接受非 const 数据，这是因为引用必须是变量的引用
- 使用 const 引用使函数能够正确生成并使用临时变量，如果实参与形参类型不匹配，则其行为类似于按值传递，为确保原始数据不被修改，将使用临时变量来存储值

```C++
#include <iostream>
#include <string>

using namespace std;

string version1(const string &s1, const string &s2);

int main()
{
    string input;
    string result;

    cout << "Enter a string: ";
    getline(cin, input);

    result = version1(input, "***");

    return 0;
}

string version1(const string &s1, const string &s2)
{
    string temp;

    temp = s2 + s1 + s2;
    return temp;
}
```

- 为了不修改字符串 input 中的值，函数的第一个形参使用 const 引用，调用函数时的第一个实参是 string 类型，因此让 s1 指向它没有任何问题
- 对于函数中的第二个形参， string 类定义了一种 char * 到 string 的转换功能，这使得可以使用C-风格字符串来初始化 string 对象(因为用引号括起的字符串常量值的本质是指向字符的指针，即 char * 类型)；但 string 类型为常量，正因为使用了 const 引用，函数将在实参与形参类型不匹配时创建一个正确类型的临时变量，使用转换后的实参值来初始化临时变量，然后传递一个指向该临时变量的引用
- 该函数中的 temp 变量只在函数内部有效，函数执行完毕之后它将不再存在，因此返回指向 temp 的引用不可行。在按值传递的过程中， temp 的内容将被复制到一个临时的存储单元中，然后在 main() 函数中，该存储单元的内容被复制到一个名为 result 的 string 中
- **综上所述，如果形参的类型为 const string & ，在调用函数时使用的实参可以是 string 对象或C-风格字符串，如用引号括起的字符串常量、以空字符结尾的 char 数组或指向 char 的指针变量**

> :rocket: **关键字 const 与 static 之间有什么异同？**

- const 与 static 都是C++的关键字，都可以用来修饰函数或变量
- const 表示只读语义，表示运行时不可修改，const修饰的对象有三种：const 对象、const 指针、const 引用，根据它修饰的具体对象来决定不可变的对象是什么以及具体的操作有哪些。因为const对象一旦创建之后就不能再改变，所以必须初始化，而不能只定义
- static 表示静态存储，被 static 修饰的对象会修改它的声明域和存储方式，但不改变作用域，局部变量还是作用于局部，全局变量依然作用于全局，但它们从声明开始，就一直存在到程序运行结束，因为它们处于静态存储区
- const 修饰的变量能且只能在定义的同时进行初始化，程序运行时不能改变其值；而 static 变量可以在程序运行期间多次赋值
- 因为C++是类特性鲜明的语言，所以 const 和 static 又有另外意义，被 const 修饰的成员函数，表明它是不会修改调用对象的内容，一般被修饰的函数都是只读取信息的函数，且可以访问类的所有成员，包括静态成员和非静态成员；而被 static 修饰的成员函数不再为某一个类对象所拥有，而是被类特有，且这种函数只可访问静态成员，不可访问非静态成员(包括成员函数和成员变量)

> :rocket: **关键字 const 的考点汇总**

- 默认情况下，const 对象被设定为仅在文件内有效，当多个文件中出现了同名的const 对象时，其实等同于在不同文件中都分别定义了独立的变量。当希望在一个文件中定义多个文件中使用 const 对象时，需要在定义 const 对象时加上 extern 关键字，以使得const对象在多个文件中都有效
- 引用只能绑定在对象上，但不能与某个字面值或表达式的计算结果绑定在一起。但在初始化常量引用时允许使用任意表达式作为初始值，只要该表达式可以转换为引用的类型即可，尤其是允许为一个常量引用绑定非常量的对象、字面值甚至是个一般表达式
```C++
    int &refVal = 10; // 错误，引用必须绑定在对象上
    double dVal = 3.14;
    int &refVal2 = dVal; // 错误，引用类型必须与其绑定的对象严格匹配

    int i = 42;
    const int &r1 = i; // 正确，允许将一个引用常量绑定到非常量对象上
    const int &r2 = 42; // 正确，允许将一个常量引用绑定到字面值上
    const int &r3 = r1 * 2; // 正确，允许将一个常量引用绑定到一个表达式上
    int &r4 = r1 * 2; // 错误，r4是普通的非常量引用
```
- 常量指针可以指向非常量对象，常量引用可以绑定非常量对象，含义是都不能通过指针或引用修改所指向或绑定对象的值，但该对象自身不一定是个常量
- 顶层 const 可以表示任意的对象是个常量，这一点对任何数据类型都适用；而底层 const 则与指针、引用等复合数据类型有关。指针类型既可以是顶层 const ，也可以是底层 const ，或者两者都是，或者两者都不是；而引用只能是底层 const ，不存在顶层 const 的引用，因为引用不是对象
- 不能忽视底层 const 在执行对象的拷贝操作时的限制。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够进行转换。一般来说，非常量可以转换为常量，反之则不行
```C++
    int i = 0;
    int *const p1 = &i; //顶层const
    const int ci = 42; //顶层const
    const int *p2 = &ci; //底层const
    const int *const p3 = p2; //既有顶层const，又有底层const
    const int &r1 = ci; //引用只能是底层const

    i = ci; //顶层const对赋值操作无影响
    p2 = p3; //正确，p2与p3所指向的对象类型相同，顶层const无影响

    int *p = p3; //错误，p3包含底层const的定义，而p没有
    p2 = &i; //正确，int * 能转换成const int *
    int &r2 = ci; //错误，非常量引用不能绑定到常量对象上
```

> :rocket: **Lambda 表达式是什么？与普通函数有何异同？**

- 共有四种可调用对象：函数、函数指针、重载了函数调用运算符的类(也称为函数符)、Lambda表达式
- Lambda表达式是C++11新增的一种形式，表示一个可调用的代码单元，可以将其理解为一个**匿名的内联函数**，语法格式如下所示。其中 capture list(捕获列表)是lambda所在函数中定义的局部非 static 变量的列表，parameter list 是参数列表，return type 是返回类型，function body 是函数体。**具体实现时可以省略参数列表与返回类型，但必须包含捕获列表与函数体**
```C++
 [capture list](parameter list) -> return type { function body }
 auto f = [] {return 42;};
 //空捕获列表表示此lambda表达式不使用它所在函数中的任何非static局部变量
```
- 与普通函数的声明方式不同：lambda表示在定义时不需要指定函数名
- 与普通函数的返回类型不同：lambda表达式可以省略返回类型，也可以由编译器根据函数体中的代码推断返回类型；在默认情况下如果一个lambda表达式包含一个 return 之外的任何语句，则编译器假定此lambda返回类型为void；若要为lambda表达式显式地声明返回类型，**必须使用尾置返回类型**，即 -> return type。而普通函数必须显式声明返回类型，既不能省略也不能使用 auto 自动类型推断
- 与普通函数的作用域不同：lambda表达式的**捕获列表只能用于局部非 static 变量**，因为它可直接访问局部 static 变量和在它所在函数之外声明的变量；而普通函数需要通过参数传递或全局变量来访问其他作用域中的变量
- 与普通函数的形参列表不同：lambda表达式的**形参列表中不能有默认参数**，一个lambda调用的实参数目永远与形参数目相等；而普通函数中可以有一个或多个默认参数，但默认参数必须放在形参列表的右侧位置
- 与普通函数的编译器实现不同：lambda表达式的类型是在编译期间生成的，而普通函数的类型是在链接期间生成的。因此，lambda表达式的类型可直接嵌入其他类型中，如容器和算法；而普通函数则需要使用函数指针或函数对象
- Lambda表达式的使用更加灵活、简洁，在函数对象、回调函数、泛型编程等场景中具有广泛的应用。但是，在使用lambda表达式时，应注意避免过多的捕获和复杂的语句块，以保证代码的可读性和维护性

> :rocket: **关键字 inline 与 define 之间有什么异同？**

## 内存管理

> :rocket: **new/delete和malloc/free之间有什么异同？**

```C++
int *p = new int[2];
int *q = (int *)malloc(2 * sizeof(int));
```

- new/delete 是运算符，而 malloc/free 是头文件 stdlib.h 中的库函数
- new/delete 操作时直接针对具体类型的指针，而函数 malloc/free 返回 void 类型的指针
- new 调用构造函数，malloc 不能；delete 调用析构函数，free 不能
- delete 和 free 被调用后，内存不会立即回收，指针也不会指向空，delete 或 free仅仅是告诉操作系统，这一块内存被释放了，可以用作其他用途。但是由于没有重新对这块内存进行写操作，所以内存中的内容并没有发生变化，进而出现野指针的情况。因此，释放完内存后应该将该指针置为空
- 程序实例详见 20230318_free和delete怎样处理指针1.c 与 20230318_free和delete怎样处理指针2.cpp

> :rocket: **指针与引用之间有什么异同？**

- 指针是对象，而引用不是对象。因此可以定义指针的指针、指针的引用、存放指针的数组、指针常量，但不能定义引用的引用、引用的指针、存放引用的数组、引用常量
```C++

    int i = 42;
    int *p; // p是一个指向int型变量的指针
    int *&r = p; // r是一个绑定指针p的引用
    r = &i; // r引用了指针p，因此给r赋值&i就是令p指向i
    *r = 0; // *r是i的别名，解引用得到i，因此给*r赋值0就是令i的值变为0

    int **q; // q是一个指向指针的指针
    q = &p; // q指向p

    int *a[10]; // a是一个含有10个指针的数组
    int (*b)[10] = &a; // b是一个指向含有10个整数的数组的指针

    int *const s; // s是一个指向int型变量的常量指针(顶层const)
    const int *t; // t是一个指向int型常量的指针(底层const)
```
- 可以把引用理解为类型的别名，因此引用必须被初始化，而指针不必，即存在空指针，但不存在不绑定任何对象的引用
- 除常量指针之外，指针可以更改所指向的对象，但无法令引用重新绑定到另外一个对象
```C++
    int iVal1 = 10;
    int iVal2 = 20;
    int &refVal1 = iVal1;
    int &refVal2; // 错误：引用必须绑定到对象
    int &refVal3 = refVal1; // 正确：refVal3绑定到了那个与refVal1绑定的对象上，此处就是绑定到了iVal1上
    refVal3 = 15; // 正确：refVal3是iVal1的别名，因此refVal3 = 15就是iVal1 = 15
    &refVal3 = iVal2; // 错误：无法令引用重新绑定到另外一个对象
```
- 可以把引用理解为变量的别名，因此使用引用所绑定的对象是可以像使用变量一样使用引用，而使用指针所指向的内容时需解引用

> :rocket: **深拷贝与浅拷贝之间有什么异同？**

- 浅拷贝和深拷贝其实是**针对拷贝对象是否存在指针成员的情况**而言的
- 当存在指针成员而且浅拷贝发生，就会使得指针被拷贝一份但指针指向内容没有拷贝，也就是它们指向的内容是同一份，会存在内存释放时造成内存泄漏的风险，而两个对象被释放也会因为两次调用delete，而实际指向内容只有一份而程序崩溃
- 深拷贝就是基于这种情况，首先开辟属于自身的内存空间，然后把指针指向的内容拷贝到自身的内存空间中，一个类要实现深拷贝就要实现拷贝构造函数和赋值运算符重载函数
- 程序实例详见 20230103_深拷贝与浅拷贝 

> :rocket: **如何理解C++中的四种智能指针?**

- 首先说⼀下为什么要使用智能指针：智能指针的作用是管理⼀个指针，避免程序员在函数结束时忘记释放申请的内存空间，进而造成内存泄漏情况的发生。使用智能指针可以很⼤程度上避免该问题，因为智能指针就是⼀个类，当智能指针对象超出了类的作用域时，类会自动调用析构函数，进而释放内存资源
- 要使用智能指针，需要包含头文件 memory ，然后使用通常的模板语法来实例化所需类型的智能指针，例如：

```C++
auto_ptr<double> pd(new double);
//new double是new返回的指针，指向新分配的内存块，它作为模板类auto_ptr的构造函数的实参
```

- 智能指针模板类的常用接口有：
```C++
T* get();//用于得到C++原生指针，这个操作是比较危险的，因为脱离了智能指针的管理
T& operator*();   
T* operator->();  
T& operator=(const T& val); 
T* release();  
void reset (T* ptr = NULL);
/*
T 是模板参数, 也就是传⼊的类型；

get()⽤来获取封装在智能指针内部的指针, 也就是获取原生指针；

operator()表示操作符重载 , operator->() 重载了->, operator=() 重载了=；

release()将封装在智能指针内部的指针置为NULL, 但并不会破坏指针所指向的内容, 函数返回的是智能指针置空之前的值；
reset()直接释放封装的内部指针所指向的内存, 如果指定了 ptr 的值, 则将内部指针初始化为该值(否则将其设置为默认参数NULL)；
*/ 
```

-  auto_ptr (C++98的方案，C++11已抛弃)采用所有权(ownership)模式

```C++
auto_ptr<std::string> p1 (new string ("hello"));
auto_ptr<std::string> p2;
p2 = p1; //auto_ptr的互相赋值，不报错
```

编译阶段不会报错！程序最终的结果是 p2 剥夺了 p1 对 string 对象的所有权，因为当执行  p2 = p1  的时候， p1 失去所有权、被置为 NULL ，这样可防止 p2 和 p1 的析构函数试图删除同一个对象。但是当其他程序运行时访问 p1 时会报错，因为它不再指向有效的数据，所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题(运行时),不能指向数组，也不能作为 STL 容器的成员

-  unique_ptr (替换 auto_ptr )

```C++
unique_ptr<string> pu1(new string ("hello world"));
unique_ptr<string> pu2；
pu2 = pu2; //报错，会留下悬挂的pu1
unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string ("you")); //不报错
```

unique_ptr 实现独占式拥有或严格拥有概念，保证同⼀时间内只有⼀个智能指针可以指向该象。它对于避免资源泄漏特别有用，即 unique_ptr 比 auto_ptr 更安全。总之，程序试图将一个 unique_ptr 赋给另一个时，如果源 unique_ptr 是个临时右值(例如调用构造函数创建匿名对象)，编译器允许这样做；但如果源 unique_ptr 将存在一段时间，编译器禁止这样做。 unique_ptr 无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值
- 智能指针模板类 auto_ptr 、 shared_ptr 使用 delete 而不是 delete [] ，因此只能与 new 一起使用，而不能与 new [] 一起使用，但 unique_ptr 拥有 new 搭配 delete 、 new[] 搭配 delete[] 的两个不同版本

```C++
auto_ptr<int> pia(new int[20]); //报错，auto_ptr只能与new一起使用

int a = 6;
auto_ptr<int> pa(&a); //报错，只能指向使用new运算符开辟的内存空间(即堆内存)，而不能使用已存在变量的内存空间

string vacation("I wandered lonely as a cloud.");
shared_ptr<string> pv(&vacation); //报错，当pv过期时，delete运算符将用于非堆内存，这是错误的
```

-  shared_ptr (共享型，强引用)： shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性( auto_ptr 是独占的)，在**使用引用计数的机制上提供了可以共享所有权**的智能指针，即多个智能指针可以指向相同对象，该对象和其相关资源会在 “最后一个引用被销毁” 时候释放。可以通过成员函数 use_count() 来查看资源的所有者个数，除了可以通过 new 来构造，还可以通过传⼊ auto_ptr 、 unique_ptr 、 weak_ptr 来构造。当调用 release() 时，当前指针会释放资源所有权，引用计数减 1；仅当引用计数等于 0 时，才调用 delete ，释放内存资源
-  weak_ptr (弱引用)：如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，也就是内存资源永远不会被释放。为解决上述问题引入了 weak_ptr ，它是一种不控制对象生命周期的智能指针，用来解决 shared_ptr 相互引用时的死锁问题。 weak_ptr 指向一个 shared_ptr 管理的对象，但进行该对象的内存管理的是强引用的  shared_ptr ， weak_ptr 只是提供了对管理对象的**一个访问手段**。 weak_ptr 设计的目的是为配合 shared_ptr 而引⼊的一种智能指针来协助 shared_ptr ⼯作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造。**它是对对象的一种弱引用，其构造函数和析构函数不会引起引用记数的增加或减少。**它和 shared_ptr 之间可以相互转化， shared_ptr 可以直接赋值给它，它可以通过调用 lock() 函数来获得 shared_ptr 。当两个智能指针都是 shared_ptr 类型的时候，析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（析构函数没有被调用），解决办法：把其中一个改为 weak_ptr 就可以(解决 shared_ptr 循环相互引用的问题)

```C++
#include <iostream>
#include <memory>

using namespace std;

class B; //前置声明
class A
{
    public:
        shared_ptr<B> pb_;
        ~A()
        {
            cout << "A delete" << endl;
        }
};
class B
{
    public:
        shared_ptr<A> pa_;
        ~B()
        {
            cout << "B delete" << endl;
        }
};
void fun()
{
    shared_ptr<B> pb(new B());
    shared_ptr<A> pa(new A());
    pb->pa_ = pa;
    pa->pb_ = pb;
    cout<<pb.use_count()<<endl;
    cout<<pa.use_count()<<endl;
}
int main()
{
    fun();
    return 0;
}
```
- 未看：C++八股文（一）：说一下C++中的智能指针？ - TripleRS的文章 - 知乎
https://zhuanlan.zhihu.com/p/617052742

## 面向对象

> :rocket: **class 与 struct 之间有什么异同?**

- 在C++中， class 与 struct 都可以被用来定义一个类，都可以在其中包含数据成员与函数成员，都可以定义构造函数、析构函数、静态成员变量等，并且它们可以互相继承
- 区别在于 class 对于数据成员的默认访问权限是 private 的，而 struct 对于数据成员的默认访问权限是 public 的；用 class 定义的类默认是 private 继承，而用 struct 定义的结构体默认是 public 继承。
```C++
    class A {
        int x;
    };
    class B : A { // 默认是private继承
        int y;
    };
    struct C {
        int x;
    };
    struct D : C { // 默认是public继承
        int y;
    };
```
- 程序实例详见 20230409_struct与class的异同.cpp

## STL部分

> :rocket: **vector 与 list 的底层实现、应用场景有何异同？**

> :rocket: **unordered_map实现原理、底层结构是什么？**

> :rocket: **unordered_map发生哈希冲突时是怎么解决的？**